\chapter{K generated code}\label{chap:gencode}

Our first stop is at the Lean code generated by K. The K Framework comes with
the
\href{https://github.com/runtimeverification/k/tree/master/pyk/src/pyk/klean}{\texttt{klean}
tool} which allows the extraction of
\href{https://kframework.org/docs/user_manual/#k-process-overview}{Kore}
definitions into a shallow embedding in Lean.

The generated code is rather
large, so we will narrow our focus down to the following:

\begin{itemize}
\item Overall structure of the generated code
\item Necessary modifications done to the generated code
\item Most used pieces
\end{itemize}

This doesn't aim to be a full description of the code generated code, but
rather, to give the reader a good enough intuition from which to take on. For a
preliminary discussion on how the code is generated, see this
\href{https://github.com/runtimeverification/k/issues/4552}{github issue}.

\section{Structure of the Code}

The generated code is divided into five files. In dependent order:

\begin{itemize}
\item \texttt{Prelude.lean}: Prelude for K definitions containing bootstrapping
  the shallow embedding.
\item \texttt{Sorts.lean}: Definition of K sorts as inductive datatypes.
\item \texttt{Inj.lean}: Instances of the \texttt{Inj} type class.
\item \texttt{Func.lean}: Extraction of declared functions.
\item \texttt{Rewrites.lean}: Rewrite rules coded as constructors or the
  \texttt{Rewrite} inductive type.
\end{itemize}

\section{Prelude}

The prelude contains the necessary definitions to bootstrap the Lean backend for
K. Since the extraction performs a shallow embedding, we need to provide the
necessary definitions that make use of already existing Lean definitions.

To give more context on what the \texttt{Prelude.lean} does, we need to
understand what are K hooked functions.

K productions can have a \texttt{hook} attribute (e.g., \href{https://github.com/runtimeverification/k/blob/master/k-distribution/include/kframework/builtin/domains.md#integer-and-bytes-conversion}{converting integers
  to bytes}), which tells K that the production will rely on an implementation
from the target backend with a given name. Since for this project the target
backend is the Lean 4 backend, \texttt{Prelude.lean} provides the definitions
needed for it.

In particular, we have the following definitions:

\subsection{Type Abbreviations}

As a part of the shallow embedding approach, we alias existing Lean types to
signal that they'll be used as K sorts.

\begin{definition}[SortBool]\label{def:SortBool}\lean{SortBool}\leanok
Alias for \texttt{Bool}.
\end{definition}
\begin{definition}[SortBytes]\label{def:SortBytes}\lean{SortBytes}\leanok
Alias for \texttt{ByteArray}.
\end{definition}
\begin{definition}[SortInt]\label{def:SortInt}\lean{SortInt}\leanok
Alias for \texttt{Int}.
\end{definition}

\subsection{Builtin Inductives}

Some embedded K sorts need to be implemented in the prelude before code
generation happens. This is because hooked functions defined in the prelude need
to have these sorts already defined.

\begin{definition}[SortEndianness]\label{def:SortEndianness}\lean{SortEndianness}\leanok
Bytes \href{https://en.wikipedia.org/wiki/Endianness}{endianness}.
\end{definition}
\begin{definition}[SortSignedness]\label{def:SortSignedness}\lean{SortSignedness}\leanok
Bytes
\href{https://en.wikipedia.org/wiki/Signed_number_representations}{signedness}
for integer representations.
\end{definition}

\subsection{\texttt{Inj} type class}
\begin{definition}[Inj]\label{Inj}\lean{Inj}\leanok
Injection type class.

Every sort in K is a subsort of the KItem sort. This type class will enable the
injections of arbitrary sorts into the KItem sort with ease.
\end{definition}
\begin{definition}[inj]\label{inj}\lean{inj}\leanok\uses{Inj}
Wrapper to \texttt{Inj.inj} to trigger type resolution.
\end{definition}

\subsection{Function Implementations}

It is now when we implement \textit{some} of the hooked functions.
Hooked productions not implemented in this prelude will be generated as axioms.

Also note that the return type of all functions is of sort \texttt{Option ?T}.
This is to deal with the generation of partial K functions.

\\
\subsubsection{\texttt{SortInt} functions}

\textbf{Arithmetic Operations:}

\begin{definition}[+Int]\label{def:+Int}\lean{«_+Int_»}\leanok\uses{def:SortInt}
\texttt{some (n + m)}
\end{definition}
\begin{definition}[-Int]\label{def:-Int}\lean{«_-Int_»}\leanok\uses{def:SortInt}
\texttt{some (n - m)}
\end{definition}
\begin{definition}[*Int]\label{def:*Int}\lean{«_*Int_»}\leanok\uses{def:SortInt}
\texttt{some (n * m)}
\end{definition}
\begin{definition}[/Int]\label{def:/Int}\lean{«_/Int_»}\leanok\uses{def:SortInt}
Truncated division.
\end{definition}
\begin{definition}[modInt]\label{def:modInt}\lean{«_modInt_»}\leanok\uses{def:SortInt}
Euclidian modulus.
\end{definition}
\begin{definition}[powMod]\label{powModInt}\lean{powmod}\leanok\uses{def:SortInt}
Integer powmod.

\textbf{Warning:} Leanblueprint has a problem with \texttt{$\backslash$lean\{\}}
references that contain special symbols. In this case, the \texttt{$\backslash$lean\{\}}
reference is \texttt{«_^\%Int__»}. This will cause the reference to be broken.
\end{definition}
\begin{definition}[maxInt]\label{maxInt}\lean{«maxInt(_,_)_INT-COMMON_Int_Int_Int»}\leanok\uses{def:SortInt}
Max operation.
\end{definition}
\begin{definition}[log2Int]\label{log2Int}\lean{«log2Int(_)_INT-COMMON_Int_Int»}\leanok\uses{def:SortInt}
$log_2$ on positive integers.
\end{definition}
\begin{definition}[notInt]\label{notInt}\leanok\uses{def:SortInt}%\lean{«~Int_»}
Integer complement.

\textbf{Warning:} Leanblueprint has a problem with \texttt{$\backslash$lean\{\}}
references that contain special symbols. In this case, the \texttt{$\backslash$lean\{\}}
reference is \texttt{«~Int_»}. This will cause the reference to be broken.
\end{definition}

\\
\subsubsection{\texttt{SortBytes} functions}

\begin{definition}[.Bytes]\label{def:.Bytes}\lean{«.Bytes_BYTES-HOOKED_Bytes»}\leanok\uses{def:SortBytes}
  Empty bytes wrapper.
\end{definition}

\\
\subsubsection{\texttt{SortInt} $\leftrightarrow$ \texttt{SortBytes} conversion}

\begin{definition}[Int2Bytes]
\label{def:Int2Bytes}\lean{«Int2Bytes(_,_,_)_BYTES-HOOKED_Bytes_Int_Int_Endianness»}
\leanok\uses{def:SortInt,def:SortBytes, def:SortEndianness}
Integer to bytes conversion.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[Byte2Int]\label{def:Bytes2Int}\lean{«Bytes2Int(_,_,_)_BYTES-HOOKED_Int_Bytes_Endianness_Signedness»}
\leanok\uses{def:SortInt,def:SortBytes,def:SortEndianness,def:SortSignedness}
Bytes to integer conversion.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\\
\subsubsection{\texttt{Bytes} manipulation}

\begin{definition}[padRightBytes]\label{def:padRightBytes}\lean{«padRightBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Pads to the right a bytes array with a specific value.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[padLeftBytes]\label{def:padLeftBytes}\lean{«padLeftBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Pads to the right a bytes array with a specific value.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[lengthBytes]\label{def:lengthBytes}\lean{«lengthBytes(_)_BYTES-HOOKED_Int_Bytes»}
\leanok\uses{def:SortBytes}
Get the length of a bytes array.
\end{definition}

\begin{definition}[replaceAtBytes]\label{def:replaceAtBytes}\lean{«replaceAtBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Bytes»}
\leanok\uses{def:SortBytes,def:SortInt}
Replace contents inside a bytes array.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[substrBytes]\label{def:substrBytes}\lean{«substrBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Slice a bytes array up.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\section{Generated Functions}

Right now there are no generated functions documented. However, we will only document those functions that play a topmost role in the theorems.

\section{Rewrite}
The
\href{https://github.com/runtimeverification/evm-equivalence/blob/master/EvmEquivalence/KEVM2Lean/Rewrite.lean}{\texttt{Rewrite.lean}}
file only contains the definition of the \texttt{Rewrites} type.

This type encodes the rewrite rules that are extracted to Lean.

\begin{definition}[Rewrites]\label{def:Rewrites}\lean{Rewrites}\leanok

Rules extracted to Lean from K will be enconded as constructors of this type.

We have that \texttt{Rewrites : SortGeneratedTopCell → SortGeneratedTopCell →
  Prop} where
\href{https://runtimeverification.github.io/evm-equivalence/docs/EvmEquivalence/KEVM2Lean/Sorts.html#SortGeneratedTopCell}{\texttt{SortGeneratedTopCell}}
is the type for KEVM states.

Given \texttt{p}, \texttt{p'} : \texttt{SortGeneratedTopCell}, \texttt{Rewrites
  p p'} means that the KEVM state \texttt{p} rewrites to \texttt{p'}.

All of the \texttt{requires} clauses of a rule are encoded as the corresponding constructor's arguments.

There's an special transitivy rule that ensures the chaining of multiple rewrite
rules:

\begin{verbatim}
| tran
  {s1 s2 s3 : SortGeneratedTopCell}
  (t1 : Rewrites s1 s2)
  (t2 : Rewrites s2 s3)
  : Rewrites s1 s3
\end{verbatim}

\end{definition}

Note that we will not be extracting all KEVM rules. Instead, we have produced
\href{https://github.com/runtimeverification/evm-semantics/tree/master/kevm-pyk/src/kevm_pyk/kproj/evm-semantics/summaries}{summary
  rules} and extracted those.

Summary rules are rules that capture KEVM's computational behavior. Executing an
opcode typically takes more than one rule application. Instead of extracting
these rules, we've put together the result of applying them as these summaries,
which KEVM can verify its correctness.

By doing this, we need only extract the summary rules to capture the semantic
meaning of executing an opcode in KEVM.

\section{Code Modifications}
The generated code produced by the \href{https://github.com/runtimeverification/k/tree/master/pyk/src/pyk/klean}{\texttt{klean}} tool has needed some small modifications.
So far, modifications have only been applied to generated functions.

In particular, modifications to the
\href{https://runtimeverification.github.io/evm-equivalence/docs/EvmEquivalence/KEVM2Lean/Func.html}{\texttt{Func.lean}}
file are for adding termination arguments to functions whenever Lean is not able
to infer it automatically.

At the moment, there are only two \texttt{mutual} blocks of functions that need
an explicit termination argument. These most important functions of those blocks
are defined here [\ref{def:gasConstSched}, \ref{def:flagConstSched}].

To prove termination we define an ordering of the schedule constants and flags
\href{https://runtimeverification.github.io/evm-equivalence/docs/EvmEquivalence/KEVM2Lean/ScheduleOrdering.html}{here}.

For example, take the \texttt{mutual} block of functions needed that defines the \texttt{«_<_>_SCHEDULE_Int_ScheduleConst_Schedule»}\ref{def:gasConstSched} function:

\begin{verbatim}
mutual
  noncomputable def SCHEDULE_GsstoreresetBerlin : SortScheduleConst → SortSchedule → Option SortInt
  | SortScheduleConst.Gsstorereset_SCHEDULE_ScheduleConst, SortSchedule.BERLIN_EVM => do
  let _Val0 <- «_<_>_SCHEDULE_Int_ScheduleConst_Schedule» SortScheduleConst.Gcoldsload_SCHEDULE_ScheduleConst SortSchedule.BERLIN_EVM
  let _Val1 <- «_-Int_» 5000 _Val0
  return _Val1
  | _, _ => none

.
.
.

  noncomputable def «_<_>_SCHEDULE_Int_ScheduleConst_Schedule» (x0 : SortScheduleConst) (x1 : SortSchedule) : Option SortInt :=
  (SCHEDULE_GaccesslistaddressBerlin x0 x1) <|>
  (SCHEDULE_GaccesslistaddressDefault x0 x1) <|>
  .
  .
  .
  (SCHEDULE_maxInitCodeSizeDefault x0 x1) <|>
  (SCHEDULE_maxInitCodeSizeShanghai x0 x1)
.
.
.
end
\end{verbatim}

When compiling this definition Lean complains about not being able to find a termination argument for the \texttt{mutual} block.
So, after defining the ordering of the schedule constants show above, the two modifications that need to be introduced in the code are the follwing:

\begin{itemize}
\item Append \texttt{termination_by (x1.toNat, x0.toNat + 1)} to the \texttt{«_<_>_SCHEDULE_Int_ScheduleConst_Schedule»} function and \texttt{termination_by sc s => (s.toNat, sc.toNat)} to the rest.
\item Add \texttt{attribute [local simp] SortScheduleConst.toNat} before the start of the \texttt{mutual} block.
\end{itemize}

It could be possible to extend the \texttt{klean} tool to generate these modifications along with the rest of the code. However, at the moment, the tool cannot generally infer missing termination arguments. This means that in order to incorporate the changes we have highlighted we would need to provide them as an override of sorts to the code that was going to be generated.
