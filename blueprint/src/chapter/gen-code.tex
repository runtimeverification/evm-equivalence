\chapter{K generated code}\label{chap:gencode}

Our first stop is at the Lean code generated by K. The K Framework comes with
the
\href{https://github.com/runtimeverification/k/tree/master/pyk/src/pyk/klean}{\texttt{klean}
tool} which allows the extraction of
\href{https://kframework.org/docs/user_manual/#k-process-overview}{Kore}
definitions into a shallow embedding in Lean.

The generated code is rather
large, so we will narrow our focous down to the following:

\begin{itemize}
\item Overall structure of the generated code
\item Necessary modifications done to the generated code
\item Most used pieces
\end{itemize}

This doesn't aim to be a full description of the code generated code, but
rather, to give the reader a good enough intuition from which to take on. For a
preliminary discussion on how the code is generated, see this
\href{https://github.com/runtimeverification/k/issues/4552}{github issue}.

\section{Structure of the Code}

The generated code is divided into five files. In dependent order:

\begin{itemize}
\item \texttt{Prelude.lean}: Prelude for K definitions containing bootstraping
  the shallow embedding
\item \texttt{Sorts.lean}: Definition of K sorts as inductive datatypes
\item \texttt{Inj.lean}: Instances of the \texttt{Inj} type class
\item \texttt{Func.lean}: Extraction of declared functions
\item \texttt{Rewrites.lean}: Rewrite rules coded as constructors or the
  \texttt{Rewrite} inductive type
\end{itemize}

\section{Prelude}

The prelude contains the necessary definitions to bootstrap the Lean backend for
K. Since the extraction performs a shallow embedding, we need to provide the
necessary definitions that make use of already existing Lean definitions.

To give more context on what the \texttt{Prelude.lean} does, we need to
understand what are K hooked functions.

K productions can have a \texttt{hook} attribute (e.g., \href{https://github.com/runtimeverification/k/blob/master/k-distribution/include/kframework/builtin/domains.md#integer-and-bytes-conversion}{converting integers
  to bytes}), which tells K that the production will rely on an implementation
from the target backend with a given name. Since for this project the target
backend is the Lean 4 backend, \texttt{Prelude.lean} provides the definitions
needed for it.

In particular, we have the following definitions:

\subsection{Type Abbreviations}

As a part of the shallow embedding approach, we alias existing Lean types to
signal that they'll be used as K sorts.

\begin{definition}[SortBool]\label{def:SortBool}\lean{SortBool}\leanok
Alias for \texttt{Bool}.
\end{definition}
\begin{definition}[SortBytes]\label{def:SortBytes}\lean{SortBytes}\leanok
Alias for \texttt{ByteArray}.
\end{definition}
\begin{definition}[SortInt]\label{def:SortInt}\lean{SortInt}\leanok
Alias for \texttt{Int}.
\end{definition}

\subsection{Builtin Inductives}

Some embedded K sorts need to be implemented in the prelude before code
generation happens. This is because hooked functions defined in the prelude need
to have these sorts already defined.

\begin{definition}[SortEndianness]\label{def:SortEndianness}\lean{SortEndianness}\leanok
Bytes \href{https://en.wikipedia.org/wiki/Endianness}{endianness}.
\end{definition}
\begin{definition}[SortSignedness]\label{def:SortSignedness}\lean{SortSignedness}\leanok
Bytes
\href{https://en.wikipedia.org/wiki/Signed_number_representations}{signedness}
for integer representations.
\end{definition}

\subsection{\texttt{Inj} type class}
\begin{definition}[Inj]\label{Inj}\lean{Inj}\leanok
Injection type class.

Every sort in K is a subsort of the KItem sort. This type class will enable the
injections of arbitrary sorts into the KItem sort with ease.
\end{definition}
\begin{definition}[inj]\label{inj}\lean{inj}\leanok\uses{Inj}
Wrapper to \texttt{Inj.inj} to trigger type resolution.
\end{definition}

\subsection{Function Implementations}

It is now when we implement \textit{some} of the hooked functions.
Hooked productions not implemented in this prelude will be generated as axioms.

Also note that the return type of all functions is of sort \texttt{Option ?T}.
This is to deal with the generation of partial K functions.

\\
\subsubsection{\texttt{SortInt} functions}

\textbf{Arithmetic Operations:}

\begin{definition}[+Int]\label{def:+Int}\lean{«_+Int_»}\leanok\uses{def:SortInt}
\texttt{some (n + m)}
\end{definition}
\begin{definition}[-Int]\label{def:-Int}\lean{«_-Int_»}\leanok\uses{def:SortInt}
\texttt{some (n - m)}
\end{definition}
\begin{definition}[*Int]\label{def:*Int}\lean{«_*Int_»}\leanok\uses{def:SortInt}
\texttt{some (n * m)}
\end{definition}
\begin{definition}[/Int]\label{def:/Int}\lean{«_/Int_»}\leanok\uses{def:SortInt}
Truncated division.
\end{definition}
\begin{definition}[modInt]\label{def:modInt}\lean{«_modInt_»}\leanok\uses{def:SortInt}
Euclidian modulus.
\end{definition}
\begin{definition}[powModInt]\label{powModInt}\lean{«_powModInt_»}\leanok\uses{def:SortInt}
Integer powmod.

\textbf{Warning:} Leanblueprint has a problem with \texttt{$\backslash$lean\{\}}
references that contain special symbols. In this case, the \texttt{$\backslash$lean\{\}}
reference is \texttt{«_^\%Int__»}. This will cause the reference to be broken.
\end{definition}
\begin{definition}[maxInt]\label{maxInt}\lean{«maxInt(_,_)_INT-COMMON_Int_Int_Int»}\leanok\uses{def:SortInt}
Max operation.
\end{definition}
\begin{definition}[log2Int]\label{log2Int}\lean{«log2Int(_)_INT-COMMON_Int_Int»}\leanok\uses{def:SortInt}
$log_2$ on positive integers.
\end{definition}
\begin{definition}[notInt]\label{notInt}\lean{«notInt_»}\leanok\uses{def:SortInt}
Integer complement.

\textbf{Warning:} Leanblueprint has a problem with \texttt{$\backslash$lean\{\}}
references that contain special symbols. In this case, the \texttt{$\backslash$lean\{\}}
reference is \texttt{«~Int_»}. This will cause the reference to be broken.
\end{definition}

\\
\subsubsection{\texttt{SortBytes} functions}

\begin{definition}[.Bytes]\label{def:.Bytes}\lean{«.Bytes_BYTES-HOOKED_Bytes»}\leanok\uses{def:SortBytes}
  Empty bytes wrapper.
\end{definition}

\\
\subsubsection{\texttt{SortInt} $\leftrightarrow$ \texttt{SortBytes} conversion}

\begin{definition}[Int2Bytes]
\label{def:Int2Bytes}\lean{«Int2Bytes(_,_,_)_BYTES-HOOKED_Bytes_Int_Int_Endianness»}
\leanok\uses{def:SortInt,def:SortBytes, def:SortEndianness}
Integer to bytes conversion.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[Byte2Int]\label{def:Bytes2Int}\lean{«Bytes2Int(_,_,_)_BYTES-HOOKED_Int_Bytes_Endianness_Signedness»}
\leanok\uses{def:SortInt,def:SortBytes,def:SortEndianness,def:SortSignedness}
Bytes to integer conversion.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\\
\subsubsection{\texttt{Bytes} manipulation}

\begin{definition}[padRightBytes]\label{def:padRightBytes}\lean{«padRightBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Pads to the right a bytes array with a specific value.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[padLeftBytes]\label{def:padLeftBytes}\lean{«padLeftBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Pads to the right a bytes array with a specific value.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[lengthBytes]\label{def:lengthBytes}\lean{«lengthBytes(_)_BYTES-HOOKED_Int_Bytes»}
\leanok\uses{def:SortBytes}
Get the length of a bytes array.
\end{definition}

\begin{definition}[replaceAtBytes]\label{def:replaceAtBytes}\lean{«replaceAtBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Bytes»}
\leanok\uses{def:SortBytes,def:SortInt}
Replace contents inside a bytes array.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\begin{definition}[substrBytes]\label{def:substrBytes}\lean{«substrBytes(_,_,_)_BYTES-HOOKED_Bytes_Bytes_Int_Int»}
\leanok\uses{def:SortBytes,def:SortInt}
Slice a bytes array up.

\textbf{Warning:} The Lean reference link is broken because the name of the
definition contains commas, and this apparently results in a new line.
\end{definition}

\section{Generated Functions}

We will only document those functions that play a topmost role in the theorems.

\subsection{Modifications to the Generated Code}

TODO

\section{Rewrite}
The Rewrite file only contains the following \texttt{Rewrites} definition.

\begin{definition}[Rewrites]\label{def:Rewrites}\lean{Rewrites}\leanok
\textbf{TODO:} Thorough explanation
\end{definition}
